"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ssh2_1 = require("ssh2");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
// const console = require("hus-console");
let debug = true;
class SFTP_Client {
    constructor(host, port, username, password) {
        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;
        this.client = new ssh2_1.Client();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.client
                    .on("ready", () => {
                    this.client.sftp((err, sftp) => {
                        if (err) {
                            return reject(err);
                        }
                        else {
                            this.sftpClient = sftp;
                            if (debug)
                                console.log("SFTP Client", "Connected");
                            return resolve();
                        }
                    });
                })
                    .on("error", (err) => {
                    switch (err.message) {
                        case "All configured authentication methods failed":
                            return reject("Invalid credencials");
                        default:
                            return reject(err);
                    }
                })
                    .connect({
                    host: this.host,
                    port: this.port,
                    username: this.username,
                    password: this.password,
                });
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    this.client.end();
                    if (debug)
                        console.log("SFTP Client", "Disconnected");
                    return resolve();
                }
                catch (err) {
                    return reject(err);
                }
            });
        });
    }
    //#region File/Directory Tools
    stat(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.sftpClient.stat(locationPath.replace(/\\/g, "/"), (err, stats) => {
                    if (err) {
                        if (err.code === 2 || err.code === 4) {
                            return reject("No such file");
                        }
                        else {
                            return reject(err);
                        }
                    }
                    else {
                        return resolve({
                            mode: stats.mode,
                            uid: stats.uid,
                            gid: stats.gid,
                            size: stats.size,
                            accessTime: stats.atime * 1000,
                            modifyTime: stats.mtime * 1000,
                            isDirectory: stats.isDirectory(),
                            isFile: stats.isFile(),
                            isBlockDevice: stats.isBlockDevice(),
                            isCharacterDevice: stats.isCharacterDevice(),
                            isSymbolicLink: stats.isSymbolicLink(),
                            isFIFO: stats.isFIFO(),
                            isSocket: stats.isSocket(),
                        });
                    }
                });
            });
        });
    }
    isFile(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    let { isFile } = yield this.stat(locationPath.replace(/\\/g, "/"));
                    return resolve(isFile);
                }
                catch (err) {
                    let msgErr;
                    if (typeof err === "string") {
                        msgErr = err + "";
                    }
                    else if (err instanceof Error) {
                        msgErr = err.message;
                    }
                    return reject(msgErr);
                }
            }));
        });
    }
    isDirectory(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    let { isDirectory } = yield this.stat(locationPath.replace(/\\/g, "/"));
                    return resolve(isDirectory);
                }
                catch (err) {
                    let msgErr;
                    if (typeof err === "string") {
                        msgErr = err + "";
                    }
                    else if (err instanceof Error) {
                        msgErr = err.message;
                    }
                    return reject(msgErr);
                }
            }));
        });
    }
    exists(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                this.sftpClient.exists(locationPath.replace(/\\/g, "/"), function (result) {
                    return resolve(result);
                });
            }));
        });
    }
    //#region File Only Tools
    uploadFile(localPath, remotePath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let filePath = path_1.default.join(remotePath.replace(/\\/g, "/"), "..");
                yield this.ensureDir(filePath + "");
                let writeStream = this.sftpClient.createWriteStream(remotePath.replace(/\\/g, "/"));
                let readStream = fs_1.default.createReadStream(localPath);
                readStream.pipe(writeStream);
                writeStream
                    .on("error", function (error) {
                    return reject(error);
                })
                    .on("finish", () => {
                    readStream.close();
                    writeStream.close();
                    return resolve();
                });
            }));
        });
    }
    rmFile(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.rmdir(locationPath.replace(/\\/g, "/"));
        });
    }
    //#endregion
    //#region Directory Only Tools
    mkdir(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.sftpClient.mkdir(locationPath.replace(/\\/g, "/"), function (err) {
                    if (err) {
                        if (err.code === 4)
                            return reject("File/Folder exists with the same name");
                        return reject(err);
                    }
                    else {
                        return resolve();
                    }
                });
            });
        });
    }
    rmdir(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.sftpClient.rmdir(locationPath.replace(/\\/g, "/"), function (err) {
                    if (err) {
                        return reject(err);
                    }
                    else {
                        return resolve();
                    }
                });
            });
        });
    }
    readdir(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                this.sftpClient.readdir(locationPath.replace(/\\/g, "/"), function (err, list) {
                    if (err) {
                        return reject(err);
                    }
                    else {
                        return resolve(list);
                    }
                });
            }));
        });
    }
    ensureDir(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let tmp = locationPath.replace(/\\/g, "/").split("/");
                tmp.shift();
                let tmpPath = "";
                for (let i = 0; i < tmp.length; i++) {
                    tmpPath += "/" + tmp[i];
                    try {
                        yield this.mkdir(tmpPath);
                    }
                    catch (err) {
                        let msgErr;
                        if (typeof err === "string") {
                            msgErr = err + "";
                        }
                        else if (err instanceof Error) {
                            msgErr = err.message;
                        }
                        if (msgErr !== "File/Folder exists with the same name" &&
                            msgErr !== "No such file or directory")
                            return reject(msgErr);
                    }
                }
                return resolve();
            }));
        });
    }
    getDirTree(locationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let dirTree = yield this.readdir(locationPath.replace(/\\/g, "/"));
                dirTree = dirTree.map((value) => {
                    return {
                        name: value.filename,
                        size: value.attrs.size,
                        mtime: value.attrs.mtime,
                    };
                });
                for (let i = 0; i < dirTree.length; i++) {
                    dirTree[i].isFile = yield this.isFile(path_1.default.join(locationPath.replace(/\\/g, "/"), dirTree[i].name));
                    dirTree[i].isDir = yield this.isDirectory(path_1.default.join(locationPath.replace(/\\/g, "/"), dirTree[i].name));
                    if (dirTree[i].isDir) {
                        dirTree[i].content = yield this.getDirTree(path_1.default.join(locationPath.replace(/\\/g, "/"), dirTree[i].name));
                    }
                }
                return resolve(dirTree);
            }));
        });
    }
}
exports.default = SFTP_Client;
