"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_client_1 = __importDefault(require("./fs_client"));
const sftp_client_1 = __importDefault(require("./sftp_client"));
const sftp_sync_client = (host, port, usernameOrToken, password, folders) => __awaiter(void 0, void 0, void 0, function* () {
    const sftpClient = new sftp_client_1.default(host, port, usernameOrToken, password);
    try {
        yield sftpClient.init();
        console.log("SFTP", `Connected to sftp server.`);
    }
    catch (err) {
        return console.log("ERROR", `Cannot connect to sftp server. Reason:`, err);
    }
    let trees = [];
    for (let i = 0; i < folders.length; i++) {
        let currentFolder = folders[i];
        console.log("SFTP", `Synthing folder: ${currentFolder.from} -> ${currentFolder.to}`);
        console.log("SFTP", `Ensuring the remote directory exists...`);
        yield sftpClient.ensureDir(currentFolder.to);
        console.log("SFTP", `Gettings remote and local directory trees...`);
        let remoteTree = yield sftpClient.getDirTree(currentFolder.to);
        let localTree = yield fs_client_1.default.getDirTree(folders[i].from);
        trees.push(Object.assign(Object.assign({}, folders[i]), { fromTree: localTree, toTree: remoteTree }));
    }
    const treeToPathList = (tree = [], currentPath = "/") => {
        let treePathList = [];
        for (let i = 0; i < tree.length; i++) {
            let thisPath = path_1.default.join(currentPath, tree[i].name);
            treePathList.push({
                path: thisPath,
                size: tree[i].size,
                mtime: tree[i].mtime,
                type: tree[i].isFile ? "file" : tree[i].isDir ? "dir" : "unkown",
            });
            if (tree[i].isDir) {
                treePathList = treePathList.concat(treeToPathList(tree[i].content, thisPath));
            }
        }
        return treePathList;
    };
    const doActions = (treePath1, treePath2, onBothHave, onPath1NotHave) => __awaiter(void 0, void 0, void 0, function* () {
        for (const fileOrDir of treePath2) {
            if (treePath1.some((e) => {
                return (e.path === fileOrDir.path &&
                    e.size === fileOrDir.size &&
                    e.type === fileOrDir.type);
            })) {
                yield onBothHave(fileOrDir.path);
            }
            else {
                if (fileOrDir.type === "file") {
                    yield onPath1NotHave({
                        type: "file",
                        path: fileOrDir.path,
                    });
                }
                else if (fileOrDir.type === "dir" && //Confirm that the dir does not exist in path1
                    !treePath1.some((e) => {
                        return e.path === fileOrDir.path && e.type === fileOrDir.type;
                    })) {
                    yield onPath1NotHave({
                        type: "dir",
                        path: fileOrDir.path,
                    });
                }
            }
        }
        return;
    });
    for (const syncDetails of trees) {
        let toFiles = treeToPathList(syncDetails.toTree);
        let fromFiles = treeToPathList(syncDetails.fromTree);
        //Decide what to delete on remote
        yield doActions(fromFiles, toFiles, (filePath) => {
            //console.log(("SFTP Sync"), `[LOCAL] Both have "${filePath}"`);
        }, (file) => __awaiter(void 0, void 0, void 0, function* () {
            switch (file.type) {
                case "file":
                    yield sftpClient.rmFile(path_1.default.normalize(path_1.default.join(syncDetails.to, file.path)));
                    console.log("SFTP Sync", `[REMOTE] Deleted file: "${file.path}"`);
                    break;
                case "dir":
                    yield sftpClient.rmdir(path_1.default.normalize(path_1.default.join(syncDetails.to, file.path)));
                    console.log("SFTP Sync", `[REMOTE] Deleted folder: "${file.path}"`);
                    break;
                default:
                    break;
            }
        }));
        //Decide what to upload to remote
        yield doActions(toFiles, fromFiles, (filePath) => {
            //console.log(("SFTP Sync"), `[REMOTE] Both have "${filePath}"`);
        }, (file) => __awaiter(void 0, void 0, void 0, function* () {
            switch (file.type) {
                case "file":
                    yield sftpClient.uploadFile(path_1.default.normalize(path_1.default.join(syncDetails.from, file.path)), path_1.default.normalize(path_1.default.join(syncDetails.to, file.path)));
                    console.log("SFTP Sync", `[REMOTE] Not have file "${file.path}"`);
                    break;
                case "dir":
                    yield sftpClient.ensureDir(path_1.default.normalize(path_1.default.join(syncDetails.to, file.path)));
                    console.log("SFTP Sync", `[REMOTE] Not have folder "${file.path}"`);
                    break;
                default:
                    break;
            }
        }));
    }
    yield sftpClient.close();
});
exports.default = sftp_sync_client;
