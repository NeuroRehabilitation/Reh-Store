import path from "path";
import fs, { getDirTreeProps } from "./fs_client";
import SFTPClient from "./sftp_client";
// const console = require('hus-console');

interface FolderProps {
  from: string;
  to: string;
}
const sftp_sync_client = async (
  host: string,
  port: number,
  usernameOrToken: string,
  password: string,
  folders: FolderProps[]
) => {
  const sftpClient = new SFTPClient(host, port, usernameOrToken, password);

  try {
    await sftpClient.init();
    console.log("SFTP", `Connected to sftp server.`);
  } catch (err) {
    return console.log("ERROR", `Cannot connect to sftp server. Reason:`,err);
  }

  let trees = [];
  for (let i = 0; i < folders.length; i++) {
    let currentFolder = folders[i];
    console.log(
      "SFTP",
      `Synthing folder: ${currentFolder.from} -> ${currentFolder.to}`
    );

    console.log("SFTP", `Ensuring the remote directory exists...`);
    await sftpClient.ensureDir(currentFolder.to);

    console.log("SFTP", `Gettings remote and local directory trees...`);
    let remoteTree = await sftpClient.getDirTree(currentFolder.to);
    let localTree = await fs.getDirTree(folders[i].from);
    trees.push({
      ...folders[i],
      fromTree: localTree,
      toTree: remoteTree,
    });
  }

  interface treeToPathListReturnType {
    path: string;
    size: number;
    mtime: number;
    type: string;
  }
  const treeToPathList = (
    tree: getDirTreeProps[] = [],
    currentPath: string = "/"
  ): treeToPathListReturnType[] => {
    let treePathList: treeToPathListReturnType[] = [];
    for (let i = 0; i < tree.length; i++) {
      let thisPath = path.join(currentPath, tree[i].name);
      treePathList.push({
        path: thisPath,
        size: tree[i].size,
        mtime: tree[i].mtime,
        type: tree[i].isFile ? "file" : tree[i].isDir ? "dir" : "unkown",
      });
      if (tree[i].isDir) {
        treePathList = treePathList.concat(
          treeToPathList(tree[i].content, thisPath)
        );
      }
    }
    return treePathList;
  };

  const doActions = async (
    treePath1: treeToPathListReturnType[],
    treePath2: treeToPathListReturnType[],
    onBothHave: (filePath: string) => void,
    onPath1NotHave: (file: { type: "dir" | "file"; path: string }) => void
  ) => {
    for (const fileOrDir of treePath2) {
      if (
        treePath1.some((e) => {
          return (
            e.path === fileOrDir.path &&
            e.size === fileOrDir.size &&
            e.type === fileOrDir.type
          );
        })
      ) {
        await onBothHave(fileOrDir.path);
      } else {
        if (fileOrDir.type === "file") {
          await onPath1NotHave({
            type: "file",
            path: fileOrDir.path,
          });
        } else if (
          fileOrDir.type === "dir" && //Confirm that the dir does not exist in path1
          !treePath1.some((e) => {
            return e.path === fileOrDir.path && e.type === fileOrDir.type;
          })
        ) {
          await onPath1NotHave({
            type: "dir",
            path: fileOrDir.path,
          });
        }
      }
    }
    return;
  };

  for (const syncDetails of trees) {
    let toFiles = treeToPathList(syncDetails.toTree);
    let fromFiles = treeToPathList(syncDetails.fromTree);

    //Decide what to delete on remote
    await doActions(
      fromFiles,
      toFiles,
      (filePath: string) => {
        //console.log(("SFTP Sync"), `[LOCAL] Both have "${filePath}"`);
      },
      async (file: { type: "dir" | "file"; path: string }) => {
        switch (file.type) {
          case "file":
            await sftpClient.rmFile(
              path.normalize(path.join(syncDetails.to, file.path))
            );
            console.log("SFTP Sync", `[REMOTE] Deleted file: "${file.path}"`);
            break;
          case "dir":
            await sftpClient.rmdir(
              path.normalize(path.join(syncDetails.to, file.path))
            );
            console.log("SFTP Sync", `[REMOTE] Deleted folder: "${file.path}"`);
            break;
          default:
            break;
        }
      }
    );

    //Decide what to upload to remote
    await doActions(
      toFiles,
      fromFiles,
      (filePath: string) => {
        //console.log(("SFTP Sync"), `[REMOTE] Both have "${filePath}"`);
      },
      async (file: { type: "dir" | "file"; path: string }) => {
        switch (file.type) {
          case "file":
            await sftpClient.uploadFile(
              path.normalize(path.join(syncDetails.from, file.path)),
              path.normalize(path.join(syncDetails.to, file.path))
            );
            console.log("SFTP Sync", `[REMOTE] Not have file "${file.path}"`);
            break;
          case "dir":
            await sftpClient.ensureDir(
              path.normalize(path.join(syncDetails.to, file.path))
            );
            console.log("SFTP Sync", `[REMOTE] Not have folder "${file.path}"`);
            break;

          default:
            break;
        }
      }
    );
  }

  await sftpClient.close();
};

export default sftp_sync_client;
