import { Client } from "ssh2";
import path from "path";
import fs from "fs";
// const console = require("hus-console");

let debug = true;
export default class SFTP_Client {
  //Client Object Storage
  client: Client;
  sftpClient: any;

  //Parameters
  host: string;
  port: number;
  username: string;
  password: string;

  constructor(host: string, port: number, username: string, password: string) {
    this.host = host;
    this.port = port;
    this.username = username;
    this.password = password;
    this.client = new Client();
  }

  async init(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      this.client
        .on("ready", () => {
          this.client.sftp((err, sftp) => {
            if (err) {
              return reject(err);
            } else {
              this.sftpClient = sftp;
              if (debug) console.log("SFTP Client", "Connected");
              return resolve();
            }
          });
        })
        .on("error", (err) => {
          switch (err.message) {
            case "All configured authentication methods failed":
              return reject("Invalid credencials");
            default:
              return reject(err);
          }
        })
        .connect({
          host: this.host,
          port: this.port,
          username: this.username,
          password: this.password,
        });
    });
  }

  async close(): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      try {
        this.client.end();

        if (debug) console.log("SFTP Client", "Disconnected");
        return resolve();
      } catch (err) {
        return reject(err);
      }
    });
  }

  //#region File/Directory Tools
  async stat(locationPath: string): Promise<{
    mode: number;
    uid: number;
    gid: number;
    size: number;
    accessTime: number;
    modifyTime: number;
    isDirectory: boolean;
    isFile: boolean;
    isBlockDevice: boolean;
    isCharacterDevice: boolean;
    isSymbolicLink: boolean;
    isFIFO: boolean;
    isSocket: boolean;
  }> {
    return new Promise((resolve, reject) => {
      this.sftpClient.stat(
        locationPath.replace(/\\/g, "/"),
        (
          err: { code: number },
          stats: {
            mode: any;
            uid: any;
            gid: any;
            size: any;
            atime: number;
            mtime: number;
            isDirectory: () => any;
            isFile: () => any;
            isBlockDevice: () => any;
            isCharacterDevice: () => any;
            isSymbolicLink: () => any;
            isFIFO: () => any;
            isSocket: () => any;
          }
        ) => {
          if (err) {
            if (err.code === 2 || err.code === 4) {
              return reject("No such file");
            } else {
              return reject(err);
            }
          } else {
            return resolve({
              mode: stats.mode,
              uid: stats.uid,
              gid: stats.gid,
              size: stats.size,
              accessTime: stats.atime * 1000,
              modifyTime: stats.mtime * 1000,
              isDirectory: stats.isDirectory(),
              isFile: stats.isFile(),
              isBlockDevice: stats.isBlockDevice(),
              isCharacterDevice: stats.isCharacterDevice(),
              isSymbolicLink: stats.isSymbolicLink(),
              isFIFO: stats.isFIFO(),
              isSocket: stats.isSocket(),
            });
          }
        }
      );
    });
  }
  async isFile(locationPath: string): Promise<boolean> {
    return new Promise<boolean>(async (resolve, reject) => {
      try {
        let { isFile } = await this.stat(locationPath.replace(/\\/g, "/"));
        return resolve(isFile);
      } catch (err: unknown) {
        let msgErr;
        if (typeof err === "string") {
          msgErr = err + "";
        } else if (err instanceof Error) {
          msgErr = err.message;
        }
        return reject(msgErr);
      }
    });
  }
  async isDirectory(locationPath: string): Promise<boolean> {
    return new Promise<boolean>(async (resolve, reject) => {
      try {
        let { isDirectory } = await this.stat(locationPath.replace(/\\/g, "/"));
        return resolve(isDirectory);
      } catch (err: unknown) {
        let msgErr;
        if (typeof err === "string") {
          msgErr = err + "";
        } else if (err instanceof Error) {
          msgErr = err.message;
        }
        return reject(msgErr);
      }
    });
  }
  async exists(locationPath: string): Promise<boolean> {
    return new Promise<boolean>(async (resolve, reject) => {
      this.sftpClient.exists(
        locationPath.replace(/\\/g, "/"),
        function (result: boolean | PromiseLike<boolean>) {
          return resolve(result);
        }
      );
    });
  }

  //#region File Only Tools
  async uploadFile(localPath: string, remotePath: string): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      let filePath = path.join(remotePath.replace(/\\/g, "/"), "..");

      await this.ensureDir(filePath + "");

      let writeStream = this.sftpClient.createWriteStream(
        remotePath.replace(/\\/g, "/")
      );
      let readStream = fs.createReadStream(localPath);

      readStream.pipe(writeStream);
      writeStream
        .on("error", function (error: any) {
          return reject(error);
        })
        .on("finish", () => {
          readStream.close();
          writeStream.close();
          return resolve();
        });
    });
  }
  async rmFile(locationPath: string): Promise<void> {
    return await this.rmdir(locationPath.replace(/\\/g, "/"));
  }

  //#endregion

  //#region Directory Only Tools
  async mkdir(locationPath: string) {
    return new Promise<void>((resolve, reject) => {
      this.sftpClient.mkdir(
        locationPath.replace(/\\/g, "/"),
        function (err: { code: number }) {
          if (err) {
            if (err.code === 4)
              return reject("File/Folder exists with the same name");
            return reject(err);
          } else {
            return resolve();
          }
        }
      );
    });
  }
  async rmdir(locationPath: string) {
    return new Promise<void>((resolve, reject) => {
      this.sftpClient.rmdir(
        locationPath.replace(/\\/g, "/"),
        function (err: any) {
          if (err) {
            return reject(err);
          } else {
            return resolve();
          }
        }
      );
    });
  }
  async readdir(locationPath: string) {
    return new Promise<any>(async (resolve, reject) => {
      this.sftpClient.readdir(
        locationPath.replace(/\\/g, "/"),
        function (err: any, list: void | PromiseLike<void>) {
          if (err) {
            return reject(err);
          } else {
            return resolve(list);
          }
        }
      );
    });
  }
  async ensureDir(locationPath: string) {
    return new Promise<void>(async (resolve, reject) => {
      let tmp = locationPath.replace(/\\/g, "/").split("/");
      tmp.shift();
      let tmpPath = "";
      for (let i = 0; i < tmp.length; i++) {
        tmpPath += "/" + tmp[i];
        try {
          await this.mkdir(tmpPath);
        } catch (err: unknown) {
          let msgErr;
          if (typeof err === "string") {
            msgErr = err + "";
          } else if (err instanceof Error) {
            msgErr = err.message;
          }

          if (
            msgErr !== "File/Folder exists with the same name" &&
            msgErr !== "No such file or directory"
          )
            return reject(msgErr);
        }
      }
      return resolve();
    });
  }
  async getDirTree(locationPath: string): Promise<any> {
    return new Promise<any>(async (resolve, reject) => {
      let dirTree = await this.readdir(locationPath.replace(/\\/g, "/"));
      dirTree = dirTree.map(
        (value: { filename: any; attrs: { size: any; mtime: any } }) => {
          return {
            name: value.filename,
            size: value.attrs.size,
            mtime: value.attrs.mtime,
          };
        }
      );
      for (let i = 0; i < dirTree.length; i++) {
        dirTree[i].isFile = await this.isFile(
          path.join(locationPath.replace(/\\/g, "/"), dirTree[i].name)
        );
        dirTree[i].isDir = await this.isDirectory(
          path.join(locationPath.replace(/\\/g, "/"), dirTree[i].name)
        );
        if (dirTree[i].isDir) {
          dirTree[i].content = await this.getDirTree(
            path.join(locationPath.replace(/\\/g, "/"), dirTree[i].name)
          );
        }
      }
      return resolve(dirTree);
    });
  }

  //#endregion

  //#endregion
}
