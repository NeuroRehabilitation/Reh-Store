"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ssh2_1 = require("ssh2");
const Bluebird = require("bluebird");
const path = require("path");
const util = require("./util");
const asyncSftpWrapper_1 = require("./asyncSftpWrapper");
const asyncFs_1 = require("./asyncFs");
const syncTable_1 = require("./syncTable");
/**
 * Creates a new SftpDeploy instance
 * @class
 */
class SftpSync {
    /**
     * Constructor
     */
    constructor(config, options) {
        /**
         * Whether a SSH2 connection has been made or not
         */
        this.connected = false;
        this.config = config;
        this.options = Object.assign({
            dryRun: false,
            exclude: [],
            excludeMode: 'remove'
        }, options);
        this.client = new ssh2_1.Client;
        this.localRoot = util.chomp(path.resolve(this.config.localDir), path.sep);
        this.remoteRoot = util.chomp(this.config.remoteDir, path.posix.sep);
    }
    /**
     * Make SSH2 connection
     */
    connect() {
        let privKeyRaw;
        return Bluebird.resolve()
            .then(() => {
            if (this.config.privateKey) {
                return asyncFs_1.fsAsync.readFile(this.config.privateKey)
                    .catch(err => {
                    throw new Error(`Local Error: Private key file not found ${this.config.privateKey}`);
                })
                    .then(privKey => {
                    privKeyRaw = privKey;
                });
            }
            else {
                return Bluebird.resolve();
            }
        })
            .then(() => {
            return new Bluebird((resolve, reject) => {
                this.client
                    .on('ready', () => {
                    this.connected = true;
                    resolve();
                })
                    .on('error', err => {
                    reject(new Error(`Connection Error: ${err.message}`));
                })
                    .connect({
                    host: this.config.host,
                    port: this.config.port || 22,
                    username: this.config.username,
                    password: this.config.password,
                    passphrase: this.config.passphrase,
                    privateKey: privKeyRaw,
                    agent: this.config.agent
                });
            });
        });
    }
    /**
     * Close SSH2 connection
     */
    close() {
        this.connected = false;
        this.client.end();
    }
    /**
     * Sync with specified path
     */
    sync(relativePath = '', isRootTask = true) {
        let doTask = (entry) => {
            let task = entry.getTask();
            let args = [entry.path, false];
            let preTask = () => {
                let preTasks = Bluebird.resolve();
                if (task.removeRemote) {
                    preTasks = preTasks.then(() => this.removeRemote(entry.path, false));
                }
                if (task.method === 'sync' && entry.remoteStat !== 'dir') {
                    preTasks = preTasks.then(() => this.createRemoteDirectory(entry.path));
                }
                return preTasks;
            };
            if (this.options.dryRun) {
                entry.dryRunLog();
                if (task.method === 'sync') {
                    return this.sync(entry.path, false);
                }
                else {
                    return Bluebird.resolve();
                }
            }
            return preTask()
                .then(() => this[task.method].apply(this, args))
                .then(() => entry.liveRunLog());
        };
        return this.buildSyncTable(relativePath)
            .get('all')
            .map(doTask)
            .return(void 0)
            .finally(() => isRootTask ? this.close() : void 0);
    }
    /**
     * Upload file/directory
     */
    upload(relativePath, isRootTask = true) {
        if (!this.sftpAsync) {
            return this.getAsyncSftp().then(() => this.upload(relativePath, isRootTask));
        }
        let localPath = this.localFullPath(relativePath);
        let remotePath = this.remoteFullPath(relativePath);
        let uploadDir = () => asyncFs_1.fsAsync.readdir(localPath)
            .map(filename => this.upload(path.posix.join(relativePath, filename), false))
            .return(void 0);
        let uploadFile = () => this.sftpAsync.fastPut(localPath, remotePath);
        return asyncFs_1.fsAsync.lstat(localPath).then(stat => stat.isDirectory() ? uploadDir() : uploadFile())
            .catch({ code: ssh2_1.SFTP_STATUS_CODE.NO_SUCH_FILE }, err => {
            throw new Error(`Remote Error: Cannot upload file ${remotePath}`);
        })
            .catch({ code: ssh2_1.SFTP_STATUS_CODE.PERMISSION_DENIED }, err => {
            throw new Error(`Remote Error: Cannot upload file. Permission denied ${remotePath}`);
        })
            .finally(() => isRootTask ? this.close() : void 0);
    }
    /**
     * Remove a remote file or directory
     */
    removeRemote(relativePath, isRootTask = true) {
        if (!this.sftpAsync) {
            return this.getAsyncSftp().then(() => this.removeRemote(relativePath, isRootTask));
        }
        let remotePath = this.remoteFullPath(relativePath);
        let removeDir = () => this.sftpAsync.readdir(remotePath)
            .map(file => this.removeRemote(path.posix.join(relativePath, file.filename), false))
            .then(() => this.sftpAsync.rmdir(remotePath));
        let removeFile = () => this.sftpAsync.unlink(remotePath);
        return this.sftpAsync.lstat(remotePath)
            .then(stat => stat.isDirectory() ? removeDir() : removeFile())
            .finally(() => isRootTask ? this.close() : void 0);
    }
    /**
     * No operation
     */
    noop() {
        return Bluebird.resolve();
    }
    /**
     * Create a directory on a remote host
     */
    createRemoteDirectory(relativePath) {
        if (!this.sftpAsync) {
            return this.getAsyncSftp().then(() => this.createRemoteDirectory(relativePath));
        }
        let remotePath = this.remoteFullPath(relativePath);
        return this.sftpAsync.mkdir(remotePath)
            .catch({ code: ssh2_1.SFTP_STATUS_CODE.NO_SUCH_FILE }, err => {
            throw new Error(`Remote Error: Cannnot create directory ${remotePath}`);
        })
            .catch({ code: ssh2_1.SFTP_STATUS_CODE.PERMISSION_DENIED }, err => {
            throw new Error(`Remote Error: Cannnot create directory. Permission denied ${remotePath}`);
        });
    }
    /**
     * Build a local and remote files status report for the specified path
     */
    buildSyncTable(relativePath) {
        if (!this.sftpAsync) {
            return this.getAsyncSftp().then(() => this.buildSyncTable(relativePath));
        }
        let localPath = this.localFullPath(relativePath);
        let remotePath = this.remoteFullPath(relativePath);
        let table = new syncTable_1.SyncTable(relativePath, this.options);
        let readLocal = () => asyncFs_1.fsAsync.readdir(localPath)
            .map(filename => {
            let fullPath = path.join(localPath, filename);
            return asyncFs_1.fsAsync.lstat(fullPath)
                .then(stat => {
                const mtime = Math.floor(new Date(stat.mtime).getTime() / 1000);
                table.set(filename, {
                    localStat: stat.isDirectory() ? 'dir' : 'file',
                    localTimestamp: mtime
                });
            })
                .catch({ code: 'EPERM' }, err => {
                table.set(filename, { localStat: 'error', localTimestamp: null });
            });
        })
            .catch({ code: 'ENOENT' }, err => {
            throw new Error(`Local Error: No such directory ${localPath}`);
        })
            .catch({ code: 'ENOTDIR' }, err => {
            throw new Error(`Local Error: Not a directory ${localPath}`);
        })
            .catch({ code: 'EPERM' }, err => {
            throw new Error(`Local Error: Cannot read directory. Permission denied ${localPath}`);
        });
        let readRemote = () => this.sftpAsync.readdir(remotePath)
            .map(file => {
            let fullPath = path.posix.join(remotePath, file.filename);
            return this.sftpAsync.lstat(fullPath)
                .then(stat => {
                if (stat.isDirectory()) {
                    return this.sftpAsync.readdir(fullPath).then(() => stat);
                }
                else {
                    return this.sftpAsync.open(fullPath, 'r+').then(() => stat);
                }
            })
                .then(stat => {
                table.set(file.filename, {
                    remoteStat: stat.isDirectory() ? 'dir' : 'file',
                    remoteTimestamp: stat.mtime
                });
            })
                .catch({ code: ssh2_1.SFTP_STATUS_CODE.PERMISSION_DENIED }, err => {
                table.set(file.filename, { remoteStat: 'error', remoteTimestamp: null });
            });
        })
            .catch({ code: ssh2_1.SFTP_STATUS_CODE.NO_SUCH_FILE }, err => {
            if (!this.options.dryRun) {
                throw new Error(`Remote Error: No such directory ${remotePath}`);
            }
        })
            .catch({ code: ssh2_1.SFTP_STATUS_CODE.PERMISSION_DENIED }, err => {
            throw new Error(`Remote Error: Cannnot read directory. Permission denied ${remotePath}`);
        });
        return Bluebird.join(readLocal(), readRemote())
            .then(() => table.forEach(entry => entry.detectExclusion()));
    }
    /**
     * Get an async version of sftp stream
     */
    getAsyncSftp() {
        if (this.sftpAsync) {
            return Bluebird.resolve(this.sftpAsync);
        }
        if (!this.connected) {
            return this.connect().then(() => this.getAsyncSftp());
        }
        const sftp = Bluebird.promisify(this.client.sftp, { context: this.client });
        return sftp().then(sftp => this.sftpAsync = new asyncSftpWrapper_1.AsyncSFTPWrapper(sftp));
    }
    /**
     * Get a full path of a local file or directory
     */
    localFullPath(relativePath) {
        return path.join(this.localRoot, relativePath);
    }
    /**
     * Get a full path of a local file or directory
     */
    remoteFullPath(relativePath) {
        return path.posix.join(this.remoteRoot, relativePath);
    }
}
exports.SftpSync = SftpSync;
